%% Part 1
clc
clear
close all
%Setting Constants
mElec = 9.11e-31; % Electron rest mass (kg)
mEff = 0.26*mElec; % Effective mass (kg)
kb = 1.381e-23; % Boltzmann's Constant (J/K)
T = 300; % Room Temperature (K)
L = 200e-9; % Length (m)
W = 100e-9; % Width (m)
q = 1.60218e-19; % Elemntary Charge (C)

% a)
Vvec = linspace(0.1, 0, 200);
Vmat = zeros(100, 200);
for k = 1:100
   Vmat(k,:) = Vvec; 
end

figure(1)
surf(Vmat)
xlabel('Length')
ylabel('Width')
zlabel('Voltage')
title('Voltage Over The Semiconductor Area')
grid on

[Ex,Ey] = gradient(-Vmat, 1e-9);
figure(2)
quiver(Ex, Ey)
xlabel('Length')
ylabel('Width')
title('Electric Field Quiver Across The Semiconductor Area')
xlim([0,200])
ylim([0,100])

% Looking at the quiver, it is obvious that the electric field across the
% region is constant. del(V) = -Ed, since d and del(V) are constant (200nm and 0.1 V respectively), the E
% field stays the same
Ehor = Ex(1, 1); % Horizontal E Field
Ever = Ey(1, 1); % Vertical E Field (Should be zero for the 0.1V on the x axis case)
fprintf('The E field is constant across the semiconductor and is equal to %f V/m in the  x direction (no y component)\n\n', Ehor)

% The results for this section are consistent with the theoretical
% expectations, Since the voltage of across the semi conductor changes
% linearly from 0.1 and only in the X direction, it is expected that the
% voltage matrix looks like a ramp. The gradient of the voltage matrix is
% constant which results in a constant E Field in the direction of the
% change in V (x direction)

% b)
Fx = q*Ehor; % Force on the electrons (in Newtons)
Fy = q*Ever; % Support for forces generated by E fields with vertical components
fprintf('Since E field is only in the x direction, the force on each electron is %f e-15 N in the x direction (no y component)\n\n', Fx*1e15)
% The force was derived from the electric field using the equation F = Eq
% where q is the charge of an electron.

% c)
% To solve for the accelerations, newton's law F = ma can be rearranged to
% a = F/m and since we already derived F from part b, the acceleration can
% be easily calculated

ax = Fx/mEff; % Horizontal Acceleration
ay = Fy/mEff; % Vertical Acceleration

fprintf('There is no vertical component to the acceleration as the force is horizontal. The acceleration is %f E15 m/s^2 x direction (no y component)\n\n', ax*1e-15)

% Using the modified code from assignment 1 to generate the 2-D plot of
% electron trajectories

% Finding the thermal velocity
Vth = sqrt((2*kb*T)/mEff); %Thermal Velocity in m/s
mt = 0.2e-12; % mean time (s)

% Modeling the electron paths

numPar = 10; % Number of particles

% Assigning particle positions
posX = L.*rand(numPar,2);
posY = W.*rand(numPar,2);
posX(:,1) = posX(:,2);
posY(:,1) = posY(:,2);

spacialStep = sqrt(L^2+W^2)/1000;
stepTime = spacialStep/Vth;

% Assigning each particle a random velocity (acceleration will be taken into account during the iteration)
Vx = randn(numPar,2)*sqrt((kb*T)/mEff);
Vy = randn(numPar,2)*sqrt((kb*T)/mEff);

% Displacement per step of each electron
dispX = stepTime*Vx(:,1);
dispY = stepTime*Vy(:,1);

colors = rand(numPar,3);

pScatter = 1 - exp(-stepTime/mt); % Probability of an electron scattering

% Positions before collision
collX = posX(:,1);
collY = posY(:,1);

ic = 0; % iteration counter for animated plot

for i = 1:1000
    % Adding the extra velocity from the acceleration (x only)
    Vx = Vx + ax*stepTime;
    Vy = Vy + ay*stepTime;
    for j = 1:numPar
        if(rand < pScatter)
            % Incrementing the collision counter and generating new
            % velocity/displacment values
            angle = 2*pi.*rand(1);
            Vx(j,:) = randn(1)*sqrt((kb*T)/mEff) + ax*stepTime;
            Vy(j,:) = randn(1)*sqrt((kb*T)/mEff) + ay*stepTime;
            dispX(j,:) = stepTime*Vx(j,1);
            dispY(j,:) = stepTime*Vy(j,1);
            collX = posX(:,1);
            collY = posY(:,1);
        end
        
        if (posX(j,1)+dispX(j) > L)
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j)-L;
        elseif (posX(j,1)+dispX(j) < 0)
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j)+L;
        else
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j);
        end
        
        if ((posY(j,1)+dispY(j) > W)|| (posY(j,1)+dispY(j) < 0))
            dispY(j) = -dispY(j);
            posY(j,2) = posY(j,1)+dispY(j);
        else
            posY(j,2) = posY(j,1)+dispY(j);
        end
    end
    if (ic == 0)
       figure(3);
       scatter(posX(:, 2),posY(:,2),1,colors(:,1));
       hold on;
       title('2-D Particle pathing');
       xlabel('Length');
       ylabel('Width');
       xlim([0 L]);
       ylim([0 W]);
    elseif (ic < 1000)
       title('2-D Particle pathing');
       scatter(posX(:, 2),posY(:,2),1,colors(:,1));
       hold on;
    else
       title('2-D Particle pathing');
       scatter(posX(:, 2),posY(:,2),1,colors(:,1));
       hold off; 
    end
    pause(0.001);
    posX(:,1) = posX(:,2);
    posY(:,1) = posY(:,2);
    ic = ic + 1;
end

% d)
% J = n*(q/density)*mean(Vn), We can get the drift current density from
% this equation using the average velocity

conc = 10^19; % concentration of electrons per m^2
numPar2 = 10000;
Vx = randn(numPar2,2)*sqrt((kb*T)/mEff);
Vy = randn(numPar2,2)*sqrt((kb*T)/mEff);
posX = L.*rand(numPar2,2);
posY = W.*rand(numPar2,2);
posX(:,1) = posX(:,2);
posY(:,1) = posY(:,2);
dispX = stepTime*Vx(:,1);
dispY = stepTime*Vy(:,1);
ic = 0;
avgVx = 0;
avgVy = 0;

for i = 1:1000
    Vx = Vx + ax*stepTime;
    Vy = Vy + ay*stepTime;
    
    avgVx(i) = mean(Vx(:,2));
    avgVy(i) = mean(Vy(:,2));
    
    for j = 1:numPar2
        if(rand < pScatter)
            Vx(j,:) = randn(1)*sqrt((kb*T)/mEff) + ax*stepTime;
            Vy(j,:) = randn(1)*sqrt((kb*T)/mEff) + ay*stepTime;
            dispX(j,:) = stepTime*Vx(j,1);
            dispY(j,:) = stepTime*Vy(j,1);
            collX = posX(:,1);
            collY = posY(:,1);
        end
        if (posX(j,1)+dispX(j) > L)
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j)-L;
        elseif (posX(j,1)+dispX(j) < 0)
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j)+L;
        else
            dispX(j,:) = stepTime*Vx(j,1);
            posX(j,2) = posX(j,1)+dispX(j);
        end
        
        if ((posY(j,1)+dispY(j) > W)|| (posY(j,1)+dispY(j) < 0))
            dispY(j) = -dispY(j);
            posY(j,2) = posY(j,1)+dispY(j);
        else
            posY(j,2) = posY(j,1)+dispY(j);
        end
    end
    timeVec(i) = stepTime*i; % time vector for plot
end
J = W*q*conc.*avgVx;
figure(4)
plot(timeVec, J)
title('Current Density vs Time')
xlabel('Time (s)')
ylabel('Current Density (A/m)')

% The current density starts at 0 at t = 0 and increases rapidly before
% converging at a specific value (around 0.01 A/m for this case)

% e)

% Electron Density Map
figure(5)
hist3([posX(:,1) posY(:,1)],[20 10])
xlabel('x-axis')
ylabel('y-axis')
zlabel('Number of electrons')
title('Electron Density Map')

% Getting the temperature and kinetic energies
Vmag = sqrt(Vx(:,1).^2 + Vy(:,1).^2); % Magnitude of particle velocities
KE = 0.5*mEff.*Vmag.^2; % Kinetic Energy
T_each = KE./kb; %Temperature of each electron

% Rounding and scaling particle positions to use them as coordinates for
% the temperature map
posX_nm = round(posX(:,1).*1e9,-1)./10;
posY_nm = round(posY(:,1).*1e9,-1)./10;

temps = zeros(round(W/1e-9)/10,round(L/1e-9)/10);

for i = 1:numPar2
    posX_nm = round(posY(i,1).*1e9,-1)/10;
    posY_nm = round(posX(i,1).*1e9,-1)/10;
    if(posX_nm <= 0 || posY_nm <= 0)
        posX_nm = 1;
        posY_nm = 1;
    end
    temps(posX_nm, posY_nm) = temps(posX_nm,posY_nm) + T_each(i); % Temperature matrix    
end

numPerBar = hist3([posX(:,1) posY(:,1)],[10 20]); % Number of electrons per bar in the temperature map

for i = 1:10
    for j = 1:20
        if(numPerBar(i,j) == 0)
            temps(i,j) = 0;
        else
            temps(i,j) = temps(i,j)/numPerBar(i,j);
        end
    end
end
temps(1,1) = 0;
figure(6)
bar3(temps)
xlabel('x-axis')
ylabel('y-axis')
zlabel('Temperature (K)')
title('Temperature Map')